---
title: "Getting Started"
subtitle: "Understanding the model components"
engine: julia
execute:
  exeflags: ["--project=.."]
---

This guide explains how to set up and run an ICOW simulation.
It covers the core model components that apply to both EAD and Stochastic modes.

## Setup

```{julia}
#| output: false
using ICOW
using Distributions
using Random
```

## The City

The `CityParameters` struct defines the physical and economic properties of the stylized coastal city.
Default values are calibrated to represent a major coastal city like Manhattan:

```{julia}
city = CityParameters()
```

Key parameters:

| Parameter | Default | Description |
|-----------|---------|-------------|
| `V_city` | $1.5 trillion | Total asset value |
| `H_city` | 17 m | Elevation range (sea level to highest point) |
| `L_city` | 43 km | Coastline length |
| `H_seawall` | 1.75 m | Existing seawall height |
| `H_bldg` | 30 m | Building height |

You can customize any parameter:

```{julia}
# A smaller city with $500 billion in assets
small_city = CityParameters(V_city=5e11)
```

## Decision Levers

The `Levers` struct defines a protection strategy with five parameters:

| Lever | Name | Description | Coordinate System |
|-------|------|-------------|-------------------|
| **W** | Withdrawal | Height below which city is relocated | Absolute (from sea level) |
| **R** | Resistance height | Height of flood-proofing | Relative to W |
| **P** | Resistance % | Fraction of damage prevented | Fraction $[0, 1)$ |
| **D** | Dike height | Height of protective barrier | Relative to dike base |
| **B** | Dike base | Elevation of dike foundation | Relative to W |

### The Five Zones

Protection strategies divide the city into zones with different damage characteristics:

```text
Sea Level (0) ────────────────────────────────────────
     |   Zone 0: WITHDRAWN
     |   - All value relocated to higher elevations
     |   - No damage possible
     +────────────────────────────────────────────────  <- W
     |   Zone 1: RESISTANT
     |   - Buildings flood-proofed to height R
     |   - Damage reduced by fraction P
     +────────────────────────────────────────────────  <- W + min(R, B)
     |   Zone 2: UNPROTECTED GAP
     |   - Full damage when flooded
     |   - Exists only if R < B
     +──────────┬─────────────────────────────────────  <- W + B (dike base)
     |   DIKE   |  Zone 3: DIKE PROTECTED
     |          |  - No damage unless dike fails/overtops
     |          |  - If dike fails: amplified damage
     +──────────┴─────────────────────────────────────  <- W + B + D (dike top)
     |   Zone 4: ABOVE-DIKE CITY
     |   - Above dike protection
     |   - Full damage when flooded
     └────────────────────────────────────────────────  <- H_city (17m)
```

### Lever Examples

The `Levers` struct supports keyword arguments with defaults of zero, making it easy to specify only the levers you need:

```{julia}
# No protection (baseline) - all defaults are zero
baseline = Levers()
```

```{julia}
# 5-meter dike at the seawall
dike_only = Levers(D=5.0)
```

```{julia}
# Combined strategy:
# - 2m withdrawal (relocate lowest areas)
# - 3m resistance height with 50% damage reduction
# - 4m dike at the seawall
combined = Levers(W=2.0, R=3.0, P=0.5, D=4.0)
```

```{julia}
# Dike set back from seawall:
# - 1m withdrawal
# - 2m resistance (30% effectiveness)
# - 5m dike with base at 3m elevation (setback)
setback_dike = Levers(W=1.0, R=2.0, P=0.3, D=5.0, B=3.0)
```

## Policy

A `StaticPolicy` wraps lever settings and applies them at the start of the simulation:

```{julia}
policy = StaticPolicy(dike_only)
```

## Forcing (Storm Surge Hazard)

The forcing defines the storm surge scenarios the city faces.
ICOW supports two forcing types for different simulation modes.

### EAD Mode: DistributionalForcing

For Expected Annual Damage (EAD) mode, specify a probability distribution for each year.
The simulator analytically integrates damage over this distribution.

```{julia}
# GEV parameters: location=1.0m, scale=0.5m, shape=0.1
surge_dist = GeneralizedExtremeValue(1.0, 0.5, 0.1)

# 50 years with stationary climate (same distribution each year)
ead_forcing = DistributionalForcing([surge_dist for _ in 1:50])
```

::: {.callout-tip}
## Non-Stationary Climate

For sea level rise or changing storm intensity, use different distributions per year:

```julia
# 1 cm/year sea level rise
forcing = DistributionalForcing([
    GeneralizedExtremeValue(1.0 + 0.01*t, 0.5, 0.1) for t in 1:50
])
```
:::

### Stochastic Mode: StochasticForcing

For Monte Carlo simulation, pre-generate surge realizations:

```{julia}
rng = Random.MersenneTwister(42)

num_scenarios = 100  # Monte Carlo samples
num_years = 50

# Generate surge matrix: [scenarios x years]
surges = rand(rng, surge_dist, num_scenarios, num_years)
stochastic_forcing = StochasticForcing(surges)
```

::: {.callout-note}
## Why Pre-Generate Scenarios?

Pre-generating enables:

1. **Reproducibility**: Same scenarios across different policies
2. **Parallelization**: Scenarios are independent
3. **Analysis**: Examine specific extreme events
:::

## Running Simulations

The `simulate` function returns total investment cost and accumulated damage.

### EAD Mode

```{julia}
investment, damage = simulate(city, policy, ead_forcing)

println("Investment cost: \$$(round(investment/1e9, digits=2)) billion")
println("Expected damage (50 years): \$$(round(damage/1e9, digits=2)) billion")
println("Total cost: \$$(round((investment + damage)/1e9, digits=2)) billion")
```

### Stochastic Mode

For stochastic mode, specify which scenario to run:

```{julia}
# Single scenario
inv, dmg = simulate(city, policy, stochastic_forcing; scenario=1, rng=rng)
println("Scenario 1 damage: \$$(round(dmg/1e9, digits=2)) billion")
```

To get statistics across all scenarios:

```{julia}
results = map(1:n_scenarios(stochastic_forcing)) do s
    inv, dmg = simulate(city, policy, stochastic_forcing; scenario=s, rng=rng)
    (investment=inv, damage=dmg)
end

damages = [r.damage for r in results]
println("Mean damage: \$$(round(mean(damages)/1e9, digits=2)) billion")
println("Std damage: \$$(round(std(damages)/1e9, digits=2)) billion")
```

## EAD vs Stochastic Mode

| Aspect | EAD Mode | Stochastic Mode |
|--------|----------|-----------------|
| **Surge events** | Integrated over distribution | Sampled from distribution |
| **Dike failure** | Expected damage (analytical) | Random failure (Bernoulli) |
| **Variability** | None (deterministic) | High (Monte Carlo noise) |
| **Speed** | Fast | Slower (needs many scenarios) |
| **Use case** | Optimization, policy comparison | Uncertainty quantification, tail risk |

Both modes converge to the same **expected value** by the Law of Large Numbers.

::: {.callout-note}
## How EAD Handles Dike Failure

EAD mode computes expected damage **analytically** for both surge uncertainty and dike failure.
For each surge height $h$, the expected damage is:

$$
\mathbb{E}[\text{damage} \mid h] = p_{\text{fail}}(h) \cdot d_{\text{failed}}(h) + (1 - p_{\text{fail}}(h)) \cdot d_{\text{intact}}(h)
$$

This inner expectation is then integrated over the surge distribution.
The result is identical to what you would get by averaging many stochastic simulations -- both modes include probabilistic dike failure, just computed differently.
:::

## Next Steps

- [EAD Analysis](ead_analysis.qmd) - Compare different protection strategies
- [EAD Optimization](ead_optimization.qmd) - Find optimal policies automatically
- [Stochastic Analysis](stochastic_analysis.qmd) - Uncertainty quantification
- [Stochastic Optimization](stochastic_optimization.qmd) - Robust optimization
