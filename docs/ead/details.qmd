---
title: "EAD Details"
subtitle: "Usage and Examples"
engine: julia
execute:
  code-fold: true
format:
  html:
    fig-format: svg
---

## Setup

```{julia}
#| code-fold: true
using ICOW
using ICOW.EAD
using Distributions
using Random
using DataFrames
using CairoMakie
```

## Configuring the City

`EADConfig` encodes the physical and economic characteristics of a coastal city: its geometry (elevation profile, building height, coastline length), the cost structure for each defense type, and damage parameters.
The 28 default values are calibrated to a Manhattan-like setting.

```{julia}
config = EADConfig()

DataFrame(
    Parameter = ["City value", "City elevation", "Building height", "Seawall height", "Coastline length"],
    Value = [config.V_city / 1e12, config.H_city, config.H_bldg, config.H_seawall, config.W_city],
    Unit = ["\$T", "m", "m", "m", "m"]
)
```

::: {.callout-note}
The default parameters are inspired by Lower Manhattan's geography and economy.
Customize any parameter via keyword arguments: `EADConfig(H_city=20.0, V_city=2.0e12)`.
:::

## Defining the Hazard

An `EADScenario` specifies the surge hazard as a vector of probability distributions -- one per year -- plus a discount rate and an integration method.
This design naturally captures **non-stationary** hazards: sea level rise, increasing storm intensity, or any other time-varying forcing.

```{julia}
n_years = 50
# Sea level rise: mean surge increases 1 cm/year
dists = [Normal(3.0 + 0.01 * t, 1.0) for t in 1:n_years]
scenario = EADScenario(dists, 0.03, QuadratureIntegrator())
```

```{julia}
fig = Figure(; size=(600, 300))
ax = Axis(fig[1, 1]; xlabel="Year", ylabel="Mean surge (m)", title="Non-stationary surge hazard")
years = 1:n_years
means = [mean(d) for d in dists]
lines!(ax, years, means; color=:steelblue, linewidth=2)
band!(ax, years, means .- 1.0, means .+ 1.0; color=(:steelblue, 0.2))
fig
```

The shaded band shows $\pm 1\sigma$ around the mean.
Over 50 years the mean annual maximum surge rises from 3.01 m to 3.50 m.

## Integration Methods

EAD mode computes expected damage by integrating over the surge distribution.
Two methods are available:

- **`QuadratureIntegrator(rtol=1e-6)`** -- adaptive Gauss-Kronrod quadrature; deterministic, precise
- **`MonteCarloIntegrator(n_samples=1000)`** -- random sampling; stochastic, flexible

::: {.callout-tip}
Use quadrature for most purposes.
Monte Carlo is mainly useful for validation or distributions where quadrature struggles (e.g., heavy mixtures).
:::

## Choosing a Protection Strategy

A `StaticPolicy` specifies protection levels using **reparameterized fractions** that guarantee all physical constraints ($W + B + D \leq H_{city}$, $0 \leq P < 1$) are always satisfied.
The policy converts to a `FloodDefenses` struct with absolute meter values:

```{julia}
policy = StaticPolicy(a_frac=0.3, w_frac=0.0, b_frac=0.2, r_frac=0.1, P=0.5)
fd = FloodDefenses(policy, config)

DataFrame(
    Defense = ["Withdrawal (W)", "Resistance height (R)", "Resistance fraction (P)", "Dike height (D)", "Berm height (B)"],
    Value = [fd.W, fd.R, fd.P, fd.D, fd.B],
    Unit = ["m", "m", "-", "m", "m"]
)
```

Different strategies allocate height budget across the three defense types in different ways:

```{julia}
archetypes = [
    ("No protection",        StaticPolicy(a_frac=0.0, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Dike only",            StaticPolicy(a_frac=0.5, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Withdraw + resist",    StaticPolicy(a_frac=0.2, w_frac=0.5, b_frac=0.0, r_frac=0.3, P=0.7)),
    ("Mixed",                StaticPolicy(a_frac=0.3, w_frac=0.1, b_frac=0.2, r_frac=0.1, P=0.5)),
    ("High dike + resist",   StaticPolicy(a_frac=0.5, w_frac=0.0, b_frac=0.1, r_frac=0.1, P=0.3)),
]

rows = map(archetypes) do (name, pol)
    fd = FloodDefenses(pol, config)
    (Name=name, W=round(fd.W; digits=2), B=round(fd.B; digits=2), D=round(fd.D; digits=2), R=round(fd.R; digits=2), P=round(fd.P; digits=2))
end
DataFrame(rows)
```

```{julia}
fig = Figure(; size=(600, 350))
ax = Axis(fig[1, 1]; xlabel="Policy", ylabel="Height (m)", title="Height allocation by strategy",
    xticks=(1:length(archetypes), first.(archetypes)), xticklabelrotation=pi/6)

names = first.(archetypes)
ws = [FloodDefenses(p, config).W for (_, p) in archetypes]
bs = [FloodDefenses(p, config).B for (_, p) in archetypes]
ds = [FloodDefenses(p, config).D for (_, p) in archetypes]

barplot!(ax, 1:length(archetypes), ws; label="W", color=:dodgerblue)
barplot!(ax, 1:length(archetypes), bs; offset=ws, label="B", color=:orange)
barplot!(ax, 1:length(archetypes), ds; offset=ws .+ bs, label="D", color=:forestgreen)
axislegend(ax; position=:lt)
fig
```

## Running a Simulation

The `simulate` function runs the full loop: initialize state, apply the policy in year 1, then compute investment costs and expected damage for each year, discounting to present value.

```{julia}
rng = MersenneTwister(42)
outcome = simulate(config, scenario, policy, rng)

DataFrame(
    Component = ["Investment", "Expected damage", "Total cost"],
    Value_B = round.([value(outcome.investment), value(outcome.expected_damage), total_cost(outcome)] ./ 1e9; digits=2)
)
```

## The Investment-Damage Tradeoff

The central question in flood risk management is how much to invest in protection.
More investment reduces expected damage but costs money upfront.
The optimal strategy minimizes total cost (investment + expected damage).

```{julia}
rng = MersenneTwister(42)
results = map(archetypes) do (name, pol)
    o = simulate(config, scenario, pol, rng)
    (Name=name,
     Investment_B=round(value(o.investment) / 1e9; digits=2),
     Expected_Damage_B=round(value(o.expected_damage) / 1e9; digits=2),
     Total_Cost_B=round(total_cost(o) / 1e9; digits=2))
end
DataFrame(results)
```

```{julia}
inv_vals = [r.Investment_B for r in results]
dmg_vals = [r.Expected_Damage_B for r in results]
names = [r.Name for r in results]

fig = Figure(; size=(600, 400))
ax = Axis(fig[1, 1]; xlabel="Investment (\$B)", ylabel="Expected Damage (\$B)",
    title="Investment vs Expected Damage")
scatter!(ax, inv_vals, dmg_vals; markersize=14, color=:steelblue)
for (i, name) in enumerate(names)
    text!(ax, inv_vals[i], dmg_vals[i]; text=name, fontsize=10, offset=(8, 4))
end
fig
```

::: {.callout-note}
This analysis is **risk-neutral**: it treats expected damage as the objective.
A risk-averse decision-maker would weight tail losses more heavily, which favors larger investments.
The [Stochastic Details](../stochastic/details.qmd) page shows how to analyze tail risk.
:::

## Sensitivity to Integration Method

Quadrature and Monte Carlo should agree when the number of samples is large enough.
Here we verify this for the mixed policy:

```{julia}
scenario_quad = EADScenario(dists, 0.03, QuadratureIntegrator())
scenario_mc = EADScenario(dists, 0.03, MonteCarloIntegrator(n_samples=10_000))

rng = MersenneTwister(42)
o_quad = simulate(config, scenario_quad, policy, rng)
rng = MersenneTwister(42)
o_mc = simulate(config, scenario_mc, policy, rng)

DataFrame(
    Method = ["Quadrature", "Monte Carlo (10k)"],
    Investment_B = round.([value(o_quad.investment), value(o_mc.investment)] ./ 1e9; digits=2),
    Expected_Damage_B = round.([value(o_quad.expected_damage), value(o_mc.expected_damage)] ./ 1e9; digits=2),
    Total_Cost_B = round.([total_cost(o_quad), total_cost(o_mc)] ./ 1e9; digits=2)
)
```
