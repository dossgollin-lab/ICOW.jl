---
title: "Stochastic Details"
subtitle: "Usage and Examples"
engine: julia
execute:
  code-fold: true
format:
  html:
    fig-format: svg
---

## Setup

```{julia}
#| code-fold: true
using ICOW
using ICOW.Stochastic
using Random
using DataFrames
using CairoMakie
using Statistics
```

## Configuring the City

`StochasticConfig` holds the same 28 city parameters as `EADConfig`.
The defaults describe a Manhattan-like coastal city.

```{julia}
config = StochasticConfig()

DataFrame(
    Parameter = ["City value", "City elevation", "Building height", "Seawall height", "Coastline length"],
    Value = [config.V_city / 1e12, config.H_city, config.H_bldg, config.H_seawall, config.W_city],
    Unit = ["\$T", "m", "m", "m", "m"]
)
```

## Defining the Surge Scenario

Unlike EAD mode (which takes distributions), Stochastic mode takes a **realized time series** of annual maximum surge heights -- one value per year.
This represents a single "what if" trajectory of storms.

```{julia}
rng = MersenneTwister(123)
n_years = 50
surges = 3.0 .+ randn(rng, n_years)

scenario = StochasticScenario(surges=surges, discount_rate=0.03)
```

```{julia}
fig = Figure(; size=(600, 300))
ax = Axis(fig[1, 1]; xlabel="Year", ylabel="Surge height (m)", title="Surge time series")
barplot!(ax, 1:n_years, surges; color=:steelblue, gap=0.1)
hlines!(ax, [config.H_seawall]; color=:red, linestyle=:dash, linewidth=2, label="Seawall ($(config.H_seawall)m)")
axislegend(ax; position=:rt)
fig
```

Surges above the seawall line cause flooding.
The dashed red line shows the existing seawall protection -- everything above it contributes to flood damage (after wave runup adjustment).

::: {.callout-tip}
In practice, you generate many surge sequences (e.g., from a GEV distribution) and simulate each one to build a distribution of outcomes.
:::

## Choosing a Protection Strategy

`StaticPolicy` uses the same reparameterized fractions as EAD mode.
Here are several archetypal strategies:

```{julia}
archetypes = [
    ("No protection",        StaticPolicy(a_frac=0.0, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Dike only",            StaticPolicy(a_frac=0.5, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Withdraw + resist",    StaticPolicy(a_frac=0.2, w_frac=0.5, b_frac=0.0, r_frac=0.3, P=0.7)),
    ("Mixed",                StaticPolicy(a_frac=0.3, w_frac=0.1, b_frac=0.2, r_frac=0.1, P=0.5)),
    ("High dike + resist",   StaticPolicy(a_frac=0.5, w_frac=0.0, b_frac=0.1, r_frac=0.1, P=0.3)),
]

rows = map(archetypes) do (name, pol)
    fd = FloodDefenses(pol, config)
    (Name=name, W=round(fd.W; digits=2), B=round(fd.B; digits=2), D=round(fd.D; digits=2), R=round(fd.R; digits=2), P=round(fd.P; digits=2))
end
DataFrame(rows)
```

## Running a Simulation

```{julia}
policy = archetypes[4][2]  # Mixed strategy
rng = MersenneTwister(42)
outcome = simulate(config, scenario, policy, rng)

DataFrame(
    Component = ["Investment", "Damage", "Total cost"],
    Value_B = round.([value(outcome.investment), value(outcome.damage), total_cost(outcome)] ./ 1e9; digits=2)
)
```

## Why Stochastic? The Role of Randomness

The same policy, scenario, and surge sequence can produce **different outcomes** because dike failure is a Bernoulli event.
Running many replicates reveals the damage distribution:

```{julia}
n_replicates = 200
damages = Float64[]
for seed in 1:n_replicates
    rng_rep = MersenneTwister(seed)
    o = simulate(config, scenario, policy, rng_rep)
    push!(damages, value(o.damage))
end
```

```{julia}
fig = Figure(; size=(600, 350))
ax = Axis(fig[1, 1]; xlabel="Damage (\$B)", ylabel="Count", title="Damage distribution ($(n_replicates) replicates)")
hist!(ax, damages ./ 1e9; bins=30, color=(:steelblue, 0.7))
mean_dmg = mean(damages) / 1e9
q05 = quantile(damages, 0.05) / 1e9
q95 = quantile(damages, 0.95) / 1e9
vlines!(ax, [mean_dmg]; color=:red, linewidth=2, label="Mean")
vlines!(ax, [q05]; color=:orange, linewidth=2, linestyle=:dash, label="5th pctile")
vlines!(ax, [q95]; color=:purple, linewidth=2, linestyle=:dash, label="95th pctile")
axislegend(ax; position=:rt)
fig
```

```{julia}
DataFrame(
    Statistic = ["Mean", "5th percentile", "95th percentile", "Std deviation"],
    Damage_B = round.([mean(damages), quantile(damages, 0.05), quantile(damages, 0.95), std(damages)] ./ 1e9; digits=2)
)
```

::: {.callout-warning}
The gap between the 5th and 95th percentiles reveals **hidden risk** that expected-value analysis misses.
A policy that looks optimal under EAD may have unacceptable tail losses.
:::

## Comparing Policies

We now run all five archetypes across many seeds to compare both average performance and tail risk:

```{julia}
n_seeds = 50
policy_results = map(archetypes) do (name, pol)
    dmgs = Float64[]
    inv = 0.0
    for seed in 1:n_seeds
        rng_rep = MersenneTwister(seed)
        o = simulate(config, scenario, pol, rng_rep)
        inv = value(o.investment)
        push!(dmgs, value(o.damage))
    end
    (Name=name,
     Investment_B=round(inv / 1e9; digits=2),
     Mean_Damage_B=round(mean(dmgs) / 1e9; digits=2),
     P95_Damage_B=round(quantile(dmgs, 0.95) / 1e9; digits=2))
end
DataFrame(policy_results)
```

```{julia}
mean_vals = [r.Mean_Damage_B for r in policy_results]
p95_vals = [r.P95_Damage_B for r in policy_results]
labels = [r.Name for r in policy_results]

fig = Figure(; size=(600, 400))
ax = Axis(fig[1, 1]; xlabel="Mean Damage (\$B)", ylabel="95th Percentile Damage (\$B)",
    title="Mean vs Tail Risk by Policy")
scatter!(ax, mean_vals, p95_vals; markersize=14, color=:steelblue)
for (i, name) in enumerate(labels)
    text!(ax, mean_vals[i], p95_vals[i]; text=name, fontsize=10, offset=(8, 4))
end
fig
```

::: {.callout-note}
Policies that reduce mean damage do not always reduce tail risk proportionally.
A dike-heavy strategy may have low average damage but catastrophic outcomes when the dike fails.
The mixed strategy balances mean and tail performance by diversifying across defense types.
:::
