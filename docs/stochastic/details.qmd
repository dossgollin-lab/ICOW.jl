---
title: "Stochastic Walkthrough"
subtitle: "Usage and Examples"
bibliography: ../references.bib
engine: julia
---

This page demonstrates how to use the Stochastic simulation mode.
Unlike EAD mode (which gives you a single expected value), Stochastic mode reveals the **distribution** of outcomes -- including tail risk that expected-value analysis hides.
This is critical when evaluating strategies that concentrate risk, like dike-heavy portfolios.

::: {.callout-tip}
## Prerequisites

If you are new to iCOW, start with the [Quickstart](../quickstart.qmd) for a gentler introduction.
This page assumes familiarity with the basic concepts (Config, Scenario, Policy, Outcome).
:::

## Setup

```{julia}
#| code-fold: true
#| output: false
using ICOW.Stochastic
using Distributions
using Random
using CairoMakie
CairoMakie.activate!(; type="svg")
using Statistics
```

## Configuring the City

`StochasticConfig` holds the same 28 city parameters as `EADConfig`.
The defaults describe a Manhattan-like coastal city.

```{julia}
config = StochasticConfig()
```

Key parameters:

- City value: \$`{julia} config.V_city / 1e12`T
- City elevation: `{julia} config.H_city` m
- Building height: `{julia} config.H_bldg` m
- Seawall height: `{julia} config.H_seawall` m

## Defining the Surge Scenario

Unlike EAD mode (which takes GEV distribution parameters), Stochastic mode takes a **realized time series** of annual maximum surge heights -- one value per year.
This represents a single "what if" trajectory of storms.
Here we sample from the GEV distribution calibrated to The Battery, NYC per @ceres_cityonawedge:2019.

```{julia}
rng = MersenneTwister(123)
n_years = 100
surge_dist = GeneralizedExtremeValue(0.935, 0.260, 0.030)
surges = rand(rng, surge_dist, n_years)

mean_sea_level = collect(range(0.0; step=0.01, length=n_years))
scenario = StochasticScenario(; surges=surges, discount_rate=0.02, mean_sea_level=mean_sea_level)
```

```{julia}
fig = Figure(; size=(600, 300))
ax = Axis(fig[1, 1]; xlabel="Year", ylabel="Surge height (m)", title="Surge time series")
barplot!(ax, 1:n_years, surges; color=:steelblue, gap=0.1)
hlines!(ax, [config.H_seawall]; color=:red, linestyle=:dash, linewidth=2, label="Seawall ($(config.H_seawall)m)")
axislegend(ax; position=:rt)
fig
```

Surges above the seawall line cause flooding.
The dashed red line shows the existing seawall protection -- everything above it contributes to flood damage (after wave runup adjustment).

::: {.callout-tip}
In practice, you generate many surge sequences (e.g., from a GEV distribution) and simulate each one to build a distribution of outcomes.
:::

## Choosing a Protection Strategy

`StaticPolicy` uses the same reparameterized fractions as EAD mode.
Here are several archetypal strategies:

```{julia}
archetypes = [
    ("No additional protection", StaticPolicy(; a_frac=0.0, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Dike only",                StaticPolicy(; a_frac=0.5, w_frac=0.0, b_frac=0.0, r_frac=0.0, P=0.0)),
    ("Withdraw + resist",        StaticPolicy(; a_frac=0.2, w_frac=0.5, b_frac=1.0, r_frac=0.3, P=0.7)),
    ("Mixed",                    StaticPolicy(; a_frac=0.3, w_frac=0.1, b_frac=0.2, r_frac=0.1, P=0.5)),
    ("High dike + resist",       StaticPolicy(; a_frac=0.5, w_frac=0.0, b_frac=0.1, r_frac=0.1, P=0.3)),
]
policies = last.(archetypes)
names = first.(archetypes)
```

## Running a Simulation

```{julia}
policy = policies[4]  # Mixed strategy
rng = MersenneTwister(42)
outcome = simulate(config, scenario, policy, rng)
outcome
```

## Why Stochastic? The Role of Storm Variability

EAD mode integrates over the surge distribution analytically, giving a single expected damage number.
But real cities experience a specific sequence of storms -- some lucky (mostly small surges), some unlucky (a rare extreme event early on).
Stochastic mode captures this by simulating many independent surge sequences, revealing the full distribution of outcomes.

```{julia}
n_scenarios = 200
rng_scenarios = MersenneTwister(42)
scenarios = [
    StochasticScenario(;
        surges=rand(rng_scenarios, surge_dist, n_years),
        discount_rate=0.02,
        mean_sea_level=mean_sea_level,
    )
    for _ in 1:n_scenarios
]

damages = [
    value(simulate(config, s, policy, MersenneTwister(i)).damage)
    for (i, s) in enumerate(scenarios)
]
```

```{julia}
fig = Figure(; size=(600, 350))
ax = Axis(fig[1, 1]; xlabel="Damage (\$B)", ylabel="Count", title="Damage distribution across $n_scenarios surge sequences")
hist!(ax, damages ./ 1e9; bins=30, color=(:steelblue, 0.7))
vlines!(ax, [mean(damages) / 1e9]; color=:red, linewidth=2, label="Mean")
vlines!(ax, [quantile(damages, 0.05) / 1e9]; color=:orange, linewidth=2, linestyle=:dash, label="5th pctile")
vlines!(ax, [quantile(damages, 0.95) / 1e9]; color=:purple, linewidth=2, linestyle=:dash, label="95th pctile")
axislegend(ax; position=:rt)
fig
```

- Mean damage: \$`{julia} round(mean(damages) / 1e9; digits=2)`B
- 5th percentile: \$`{julia} round(quantile(damages, 0.05) / 1e9; digits=2)`B
- 95th percentile: \$`{julia} round(quantile(damages, 0.95) / 1e9; digits=2)`B

::: {.callout-warning}
The gap between the 5th and 95th percentiles reveals **hidden risk** that expected-value analysis misses.
A policy that looks optimal under EAD may have unacceptable tail losses.
:::

## Comparing Policies

We use `explore()` to evaluate all five policies across many independent surge sequences.
Each scenario is a different realization of storm history over the planning horizon:

```{julia}
result = explore(config, scenarios, policies; progress=false)
result
```

The result is a YAXArrays Dataset with dimensions `(policy, scenario)`.
Each scenario is an independent surge sequence, so the scenario dimension captures storm variability:

```{julia}
# Mean and 95th percentile damage across scenarios for each policy
mean_dmg = [mean(result[:damage].data[p, :]) for p in 1:length(policies)] ./ 1e9
p95_dmg = [quantile(result[:damage].data[p, :], 0.95) for p in 1:length(policies)] ./ 1e9

fig = Figure(; size=(600, 400))
ax = Axis(fig[1, 1]; xlabel="Mean Damage (\$B)", ylabel="95th Percentile Damage (\$B)",
    title="Mean vs Tail Risk by Policy")
scatter!(ax, mean_dmg, p95_dmg; markersize=14, color=:steelblue)
for (i, name) in enumerate(names)
    text!(ax, mean_dmg[i], p95_dmg[i]; text=name, fontsize=10, offset=(8, 4))
end
fig
```

::: {.callout-note}
## Mean vs. Tail Risk

Policies that reduce mean damage do not always reduce tail risk proportionally.
A dike-heavy strategy may have low average damage but catastrophic outcomes when the dike fails.
The mixed strategy balances mean and tail performance by diversifying across defense types.

This distinction matters for decision making: a **risk-neutral** decision-maker cares only about expected cost and would use EAD mode.
A **risk-averse** decision-maker weights bad outcomes more heavily and needs the distributional information that Stochastic mode provides.
Which perspective is appropriate depends on the decision context -- see @keller_management:2021 for a broader discussion.
:::
